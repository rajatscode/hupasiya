# Context Structure

Detailed specification of the `.hp/` directory structure and context management.

## Directory Layout

```
.hp/
├── config.yml                           # hp-specific config
├── contexts/
│   └── <repo-name>/
│       ├── global/                      # Repo-wide context (shared)
│       │   ├── architecture.md
│       │   ├── conventions.md
│       │   ├── patterns.md
│       │   ├── dependencies.md
│       │   └── gotchas.md
│       ├── shared/                      # Shared between sessions
│       │   ├── api-patterns.md
│       │   └── testing-guide.md
│       └── <session-name>/              # Session-specific context
│           ├── context.md               # Main context file
│           ├── conversation.json        # AI chat history
│           ├── shepherd.md              # PR comments (shepherd type)
│           ├── activity.json            # Activity log
│           ├── metrics.json             # Session metrics
│           ├── snapshots/               # Context snapshots
│           │   ├── 2025-01-12_initial.md
│           │   ├── 2025-01-15_after_review.md
│           │   └── 2025-01-20_final.md
│           └── .lock                    # Lock file (if locked)
├── sessions/
│   ├── <repo>-<session1>.yaml          # Session metadata
│   ├── <repo>-<session2>.yaml
│   └── <repo>-<session3>.yaml
├── templates/
│   ├── local/                           # Local templates
│   │   ├── feature.md
│   │   ├── bugfix.md
│   │   ├── test.md
│   │   ├── docs.md
│   │   ├── shepherd.md
│   │   ├── refactor.md
│   │   ├── research.md
│   │   └── review.md
│   └── marketplace/                     # Downloaded templates
│       ├── <author>/
│       │   └── <template-name>/
│       │       ├── template.md
│       │       └── metadata.yml
│       └── cache.json                   # Template cache
└── cache/                               # Temporary cache
    ├── templates/                       # Template downloads
    └── workbox-info/                    # Cached workbox info
```

## Separation from hannahanna

hupasiya manages `.hp/` directory, hannahanna manages `.hn-state/`:

```
repo/
├── .git/                   # Git repository
├── .hn-state/             # hannahanna state (DO NOT TOUCH)
│   ├── workboxes.json
│   ├── docker/
│   └── logs/
├── .hp/                   # hupasiya state (managed by hp)
│   ├── contexts/
│   └── sessions/
├── .hannahanna.yml        # hannahanna config
└── .hapusiyas.yml         # hupasiya config
```

**Important**: hupasiya never modifies `.hn-state/`, hannahanna never modifies `.hp/`.

## Context Files

### Main Context File

**Location**: `.hp/contexts/<repo>/<session>/context.md`

**Purpose**: Primary context for AI agent

**Format**: Markdown with frontmatter

**Example**:

```markdown
---
session: auth-feature
type: feature
created: 2025-01-12T14:30:00Z
parent: null
tags: [oauth, authentication, security]
---

# Feature: OAuth Authentication

## Objective

Implement OAuth 2.0 authentication with support for Google and GitHub providers.

## User Story

As a user
I want to log in with my Google or GitHub account
So that I don't have to create another password

## Requirements

- [ ] OAuth 2.0 authorization code flow
- [ ] Support Google OAuth
- [ ] Support GitHub OAuth
- [ ] Token refresh logic
- [ ] Secure token storage
- [ ] Handle OAuth errors gracefully

## Approach

1. **Design**: Research OAuth 2.0 best practices
2. **Backend**: Implement OAuth endpoints
3. **Frontend**: Add OAuth buttons and callback handling
4. **Storage**: Implement secure token storage
5. **Testing**: Add OAuth integration tests
6. **Documentation**: Document OAuth setup

## Tasks

- [ ] Set up OAuth app in Google Console
- [ ] Set up OAuth app in GitHub
- [ ] Implement OAuth redirect endpoint
- [ ] Implement token exchange
- [ ] Implement token refresh
- [ ] Add OAuth buttons to login page
- [ ] Handle OAuth callback
- [ ] Store tokens securely
- [ ] Add error handling
- [ ] Write tests
- [ ] Update documentation

## Notes

- Use PKCE for additional security
- Store tokens in httpOnly cookies
- Set up OAuth apps in dev, staging, prod environments
- Consider using a library like `oauth2-rs`

## Links

- [OAuth 2.0 Spec](https://oauth.net/2/)
- [Google OAuth Docs](https://developers.google.com/identity/protocols/oauth2)
- [GitHub OAuth Docs](https://docs.github.com/en/developers/apps/building-oauth-apps)
```

### Shepherd Context File

**Location**: `.hp/contexts/<repo>/<session>/shepherd.md`

**Purpose**: PR review comments for shepherd workflow

**Format**: Markdown with structured sections

**Auto-generated by**: `hp shepherd`

**Example**:

```markdown
# PR Review Comments - PR #123

**PR Title**: Add OAuth authentication
**PR URL**: https://github.com/org/repo/pull/123
**Status**: open
**Comments**: 4 unresolved, 12 resolved

---

## Comment 1: `src/auth/oauth.rs:45`

**Author**: @bob
**Created**: 2025-01-14T10:30:00Z
**Status**: ❌ Unresolved

### Code Context

```diff
@@ -42,7 +42,10 @@
 pub async fn exchange_token(code: &str) -> Result<TokenResponse> {
-    let client = create_oauth_client()?;
-    let token = client.exchange_code(code).await?;
+    let client = create_oauth_client();
+    let token = client.exchange_code(code).await;
     Ok(token)
 }
```

### Comment

> Need better error handling here. What happens if the token exchange fails?
> Should we retry? Log the error? Return a user-friendly error message?

### Discussion

*No replies yet*

---

## Comment 2: `src/auth/oauth.rs:67`

**Author**: @bob
**Created**: 2025-01-14T10:32:00Z
**Status**: ❌ Unresolved

### Code Context

```diff
@@ -64,6 +67,8 @@
 pub async fn refresh_token(refresh_token: &str) -> Result<TokenResponse> {
     let client = create_oauth_client()?;
-    let token = client.refresh_token(refresh_token).await?;
+    let token = client.refresh_token(refresh_token).await;
     Ok(token)
 }
```

### Comment

> Add rate limiting here. We shouldn't spam the OAuth provider if refresh fails.

---

## Comment 3: `tests/auth.rs:123`

**Author**: @alice
**Created**: 2025-01-14T11:15:00Z
**Status**: ❌ Unresolved

### Code Context

```rust
#[test]
fn test_oauth_flow() {
    // Test OAuth flow
}
```

### Comment

> Add test for edge case: What if the user denies the OAuth request?

---

## Comment 4: `docs/auth.md:12`

**Author**: @alice
**Created**: 2025-01-14T11:20:00Z
**Status**: ❌ Unresolved

### Comment

> Update API docs to show how to use the new OAuth endpoints.

---

## Progress

- [ ] Comment 1 - Error handling in token exchange
- [ ] Comment 2 - Rate limiting for token refresh
- [ ] Comment 3 - Test OAuth denial
- [ ] Comment 4 - Update API docs

## AI Analysis

*Run `hp shepherd --dry-run` to see AI analysis of these comments*
```

After running `hp shepherd`, AI analysis is appended:

```markdown
## AI Analysis

### Comment 1: `src/auth/oauth.rs:45` - Error handling

**Action**: FIX
**Confidence**: HIGH

**Assessment**: Reviewer is right. Current code doesn't handle token exchange errors properly.

**Suggested Changes**:
```diff
 pub async fn exchange_token(code: &str) -> Result<TokenResponse> {
     let client = create_oauth_client()?;
-    let token = client.exchange_code(code).await?;
+    let token = client.exchange_code(code).await
+        .map_err(|e| {
+            error!("Token exchange failed: {}", e);
+            AuthError::TokenExchangeFailed(e.to_string())
+        })?;
     Ok(token)
 }
```

**Response Draft**:
> Good catch! Added proper error handling with logging and user-friendly error messages.

---

### Comment 2: `src/auth/oauth.rs:67` - Rate limiting

**Action**: FIX
**Confidence**: MEDIUM

**Assessment**: Rate limiting is important but implementation depends on architecture.

**Suggested Changes**:
```rust
use governor::{Quota, RateLimiter};

// Add rate limiter
static RATE_LIMITER: Lazy<RateLimiter> = Lazy::new(|| {
    RateLimiter::direct(Quota::per_second(5))
});

pub async fn refresh_token(refresh_token: &str) -> Result<TokenResponse> {
    // Check rate limit
    RATE_LIMITER.check().map_err(|_| AuthError::RateLimited)?;

    let client = create_oauth_client()?;
    let token = client.refresh_token(refresh_token).await?;
    Ok(token)
}
```

**Response Draft**:
> Added rate limiting (5 requests/second) using the governor crate. This prevents spamming the OAuth provider.

---

### Comment 3: `tests/auth.rs:123` - Test OAuth denial

**Action**: FIX
**Confidence**: HIGH

**Assessment**: Important edge case test is missing.

**Suggested Changes**:
```rust
#[test]
fn test_oauth_denial() {
    let result = handle_oauth_callback("error=access_denied");
    assert!(matches!(result, Err(AuthError::AccessDenied)));
}
```

**Response Draft**:
> Added test for OAuth denial case. Thanks for catching this!

---

### Comment 4: `docs/auth.md:12` - Update API docs

**Action**: FIX
**Confidence**: HIGH

**Assessment**: Documentation needs to be updated with new OAuth endpoints.

**Suggested Changes**:
```markdown
## OAuth Authentication

### Endpoints

**POST /auth/oauth/authorize**
Initiates OAuth flow

**GET /auth/oauth/callback**
Handles OAuth callback

**POST /auth/oauth/refresh**
Refreshes access token

### Example

\`\`\`bash
# Initiate OAuth
curl -X POST https://api.example.com/auth/oauth/authorize?provider=google

# Response: redirect URL
\`\`\`
```

**Response Draft**:
> Updated API docs with OAuth endpoints and examples.
```

### Conversation History

**Location**: `.hp/contexts/<repo>/<session>/conversation.json`

**Purpose**: Full AI conversation history for session

**Format**: JSON

**Example**:

```json
{
  "session_id": "550e8400-e29b-41d4-a716-446655440000",
  "session_name": "auth-feature",
  "messages": [
    {
      "role": "user",
      "content": "Implement OAuth login with Google",
      "timestamp": "2025-01-12T14:35:00Z",
      "tokens": null
    },
    {
      "role": "assistant",
      "content": "I'll implement OAuth login with Google. First, let me create the OAuth client configuration...",
      "timestamp": "2025-01-12T14:35:15Z",
      "tokens": 1234
    },
    {
      "role": "user",
      "content": "Also add GitHub OAuth",
      "timestamp": "2025-01-12T15:20:00Z",
      "tokens": null
    },
    {
      "role": "assistant",
      "content": "I'll add GitHub OAuth as well. Let me create a generic OAuth provider interface...",
      "timestamp": "2025-01-12T15:20:10Z",
      "tokens": 2156
    }
  ],
  "total_tokens": 3390,
  "total_messages": 4,
  "ai_interactions": 2
}
```

### Activity Log

**Location**: `.hp/contexts/<repo>/<session>/activity.json`

**Purpose**: Track all session activity

**Format**: JSON

**Example**:

```json
{
  "session_id": "550e8400-e29b-41d4-a716-446655440000",
  "session_name": "auth-feature",
  "events": [
    {
      "timestamp": "2025-01-12T14:30:00Z",
      "type": "session_created",
      "details": "Created feature session for OAuth authentication"
    },
    {
      "timestamp": "2025-01-12T14:35:00Z",
      "type": "ai_launched",
      "details": "Launched Claude Code"
    },
    {
      "timestamp": "2025-01-12T16:45:00Z",
      "type": "commit_made",
      "details": "Commit: Add OAuth client configuration"
    },
    {
      "timestamp": "2025-01-13T10:00:00Z",
      "type": "child_added",
      "details": "Added child session: auth-tests"
    },
    {
      "timestamp": "2025-01-13T11:30:00Z",
      "type": "cascaded",
      "details": "Cascaded to auth-tests"
    },
    {
      "timestamp": "2025-01-14T09:00:00Z",
      "type": "pr_created",
      "details": "Created PR #123: Add OAuth authentication"
    },
    {
      "timestamp": "2025-01-14T10:30:00Z",
      "type": "pr_comment_received",
      "details": "Received 4 PR comments from bob, alice"
    },
    {
      "timestamp": "2025-01-14T14:00:00Z",
      "type": "shepherd_run",
      "details": "Ran shepherd, addressed 3 comments"
    }
  ]
}
```

### Metrics

**Location**: `.hp/contexts/<repo>/<session>/metrics.json`

**Purpose**: Track quantitative metrics

**Format**: JSON

**Example**:

```json
{
  "session_id": "550e8400-e29b-41d4-a716-446655440000",
  "session_name": "auth-feature",
  "total_time_seconds": 12300,
  "commits": 12,
  "lines_added": 523,
  "lines_removed": 145,
  "files_changed": 8,
  "ai_interactions": 45,
  "tokens_used": 125432,
  "updated_at": "2025-01-15T09:15:00Z"
}
```

### Snapshots

**Location**: `.hp/contexts/<repo>/<session>/snapshots/`

**Purpose**: Point-in-time context backups

**Naming**: `YYYY-MM-DD_<name>.md`

**Example**: `2025-01-12_initial.md`

Snapshots are copies of `context.md` at specific points in time.

**Auto-created**:
- Before cascade
- Before gather
- After PR review
- On pause
- Before major operations

**Manual**: `hp context snapshot <session> <name>`

## Global Context

**Location**: `.hp/contexts/<repo>/global/`

**Purpose**: Repo-wide context shared by all sessions

**Files**:

### `architecture.md`

```markdown
# System Architecture

## Overview

This is a microservices architecture with:
- API Gateway (Rust + Axum)
- Auth Service (Rust + OAuth)
- User Service (Rust + Postgres)
- Frontend (React + TypeScript)

## Services

### API Gateway
- Routes requests to services
- Handles auth middleware
- Rate limiting

### Auth Service
- OAuth 2.0 authentication
- JWT token management
- Session management

### User Service
- User CRUD operations
- Profile management
- Settings

## Communication

Services communicate via:
- REST APIs (external)
- gRPC (internal)
- Message queue (async events)

## Data Flow

1. User → API Gateway
2. API Gateway → Auth check
3. API Gateway → Service
4. Service → Database
5. Service → API Gateway
6. API Gateway → User
```

### `conventions.md`

```markdown
# Code Conventions

## Rust

- Use `rustfmt` for formatting
- Use `clippy` for linting
- All public APIs must have doc comments
- Error handling: Use `anyhow` for applications, `thiserror` for libraries
- Testing: Minimum 80% coverage

## Git

- Commit messages: Conventional Commits format
- Branch naming: `feature/`, `fix/`, `refactor/`, `docs/`
- PR description: Include issue number, summary, test plan

## Documentation

- All public APIs documented
- README for each service
- API docs auto-generated
- Keep docs up to date with code
```

### `patterns.md`

```markdown
# Common Patterns

## Error Handling

```rust
use anyhow::{Context, Result};

pub fn do_something() -> Result<()> {
    let file = File::open("config.yml")
        .context("Failed to open config file")?;

    // ...

    Ok(())
}
```

## Async Patterns

```rust
use tokio::task;

#[tokio::main]
async fn main() {
    let task1 = task::spawn(async { /* ... */ });
    let task2 = task::spawn(async { /* ... */ });

    let (result1, result2) = tokio::join!(task1, task2);
}
```

## Testing Patterns

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_something() {
        // Arrange
        let input = create_test_input();

        // Act
        let result = do_something(input);

        // Assert
        assert_eq!(result, expected);
    }
}
```
```

## Shared Context

**Location**: `.hp/contexts/<repo>/shared/`

**Purpose**: Context files shared between specific sessions

**Usage**: Link from session contexts

**Example**:

`shared/api-patterns.md`:
```markdown
# API Patterns

## RESTful Design

- Use proper HTTP methods (GET, POST, PUT, DELETE)
- Use proper status codes
- Use versioning (/v1/, /v2/)

## Error Responses

```json
{
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Invalid email address",
    "details": {
      "field": "email",
      "value": "invalid"
    }
  }
}
```
```

Sessions can reference this:

```markdown
# Session Context

## Approach

Follow [API Patterns](../../shared/api-patterns.md) for consistent API design.
```

## AI Tool Integration

### Environment Variables

When `hp launch` or `hp switch` is used, these environment variables are set:

```bash
HP_SESSION="auth-feature"
HP_CONTEXT="/path/to/.hp/contexts/myrepo/auth-feature/context.md"
HP_WORKBOX="/path/to/repo-wt-auth-feature"
HP_VCS="git"
HP_REPO="myrepo"
HP_BRANCH="feature/auth"
HP_BASE_BRANCH="main"
```

### Custom Instructions / Slash Commands

For AI tools that support custom instructions or slash commands (Claude Code, Cursor, etc.):

**Claude Code**: Create `~/.claude/commands/hp-context.md`:

```markdown
Read the session context at: $HP_CONTEXT

If there's a shepherd file at the same directory with name `shepherd.md`, read that too for PR review comments.
```

**Cursor**: Add to `.cursor/settings.json`:

```json
{
  "rules": [
    "Read session context from $HP_CONTEXT environment variable",
    "Check for shepherd.md in the same directory for PR comments"
  ]
}
```

**Codex (OpenAI API)**: Pass as system message:

```python
import os

context_path = os.environ.get('HP_CONTEXT')
if context_path:
    with open(context_path) as f:
        context = f.read()

    messages = [
        {"role": "system", "content": f"Session context:\n{context}"},
        {"role": "user", "content": user_message}
    ]
```

### Launch Methods

Configured via `.hapusiyas.yml`:

```yaml
hp:
  ai_tool:
    command: claude-code  # or cursor, codex, etc.
    launch_method: exec   # exec, shell_function, tmux, screen
    context_strategy: slash_command  # slash_command, flag, env, file
    extra_args: []
    env:
      HP_SESSION: "{{session_name}}"
      HP_CONTEXT: "{{context_file}}"
      HP_WORKBOX: "{{workbox_path}}"
```

**Methods**:
- `exec`: Direct execution (`claude-code`)
- `shell_function`: Call shell function (`launch_claude`)
- `tmux`: Launch in tmux pane
- `screen`: Launch in screen session

**Context Strategies**:
- `slash_command`: Use tool's slash command system
- `flag`: Pass as command-line flag (`--context=$HP_CONTEXT`)
- `env`: Set environment variables only
- `file`: Write to tool's config file

## File Permissions

- Context files: `0600` (user read/write only)
- Session metadata: `0600`
- Conversation history: `0600` (sensitive)
- Templates: `0644` (world-readable)
- Directories: `0700` (user only)

## Gitignore

Always add to `.gitignore`:

```gitignore
# hupasiya
.hp/contexts/*/conversation.json
.hp/contexts/*/activity.json
.hp/contexts/*/metrics.json
.hp/contexts/*/snapshots/
.hp/contexts/*/.lock
.hp/cache/
.hapusiyas.local.yml
```

Commit to git:
```gitignore
# hupasiya (committed)
.hp/contexts/*/context.md
.hp/contexts/*/shepherd.md
.hp/contexts/global/
.hp/contexts/shared/
.hp/templates/local/
.hapusiyas.yml
```

## Context Size Limits

To keep contexts manageable:

- Main context: <50KB recommended
- Shepherd context: Auto-generated, no limit
- Conversation history: No limit (JSON compressed)
- Activity log: 90 days retention (configurable)
- Snapshots: Keep last 10 (configurable)

## Best Practices

1. **Keep context focused**: One objective per session
2. **Use templates**: Start with template for consistency
3. **Link to shared context**: Don't duplicate
4. **Snapshot frequently**: Before major changes
5. **Clean up old sessions**: Archive or delete completed work
6. **Use global context**: For repo-wide patterns and conventions
7. **Lock when handing off**: Prevent conflicts
8. **Export metrics**: For reporting and analysis
